#!/bin/sh

calc_tempdir() {
    prefix="${1:-filter-branch}"
    tempdir=$(
        mktemp -d /dev/shm/"$prefix".XXXXX ||
        mktemp -d /tmp/"$prefix".XXXXX ||
        echo ".git-rewrite"
    )

    rm -rf "$tempdir"

    echo "using $tempdir as temporary directory" >&2
    echo "$tempdir"
}
# delete git-filter-branch backup refs.
delete_fb_backups() {
    git for-each-ref --format="%(refname)" ${1:-refs/original/} | \
    xargs --no-run-if-empty -n 1 git update-ref -d
}

# some first commits for a branch contain only the changed files in that branch
# This makes the git revision appear as deleting all the rest of the tree.
# Here we filter all revisions in the branch
# to contain the rest of the files, taken from the master revision right before branching.
# this code initially copied from kdegraphics/okular, but did not work for me.
# I had to replace master.. by ${prevmaster}..

fill_branch() {
	branch=$1
	mastercommit=$2
	tempdir="$(calc_tempdir $REPO-filter)"
	prevmaster=$(echo $mastercommit | $bindir/translateRevlist.py)
	echo fill_branch $branch $mastercomit mit tempdir: $tempdir und prevmaster: $prevmaster

        range="${prevmaster}..${branch}"
	echo range:$range
	echo git filter-branch -f -d "$tempdir" \
		--tree-filter "git read-tree $prevmaster" \
		--tag-name-filter cat \
		$range
	git filter-branch -f -d "$tempdir" \
		--tree-filter "git read-tree $prevmaster" \
		--tag-name-filter cat \
		$range
}

# add a tag to every commit, name=svn revision
# ignores empty tagging commits (those removed by fix-tags)
# this helps much with visual debugging with gitk --all. Note
# however that gitk --all might then not show all branches for
# a commit for whatever reason.
add_revision_tags() {
	branches=$(git branch -a | grep -v HEAD | sed 's/ //g' | sed 's/^*//')
	git log --pretty=%h $branches | sort | uniq | while read commit
	do
		revision=r$(git show --pretty='%b' $commit | grep 'svn path=' | sed 's/.*revision=//')
		# a revision can appear more than once if it changes several branches
		test -r refs/tags/$revision && revision=${revision}X
		test -r refs/tags/$revision && revision=${revision}X
		test -r refs/tags/$revision && revision=${revision}X
		git tag $revision $commit
	done
}
